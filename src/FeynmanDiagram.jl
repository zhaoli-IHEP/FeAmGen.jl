
#######################################################
"""
    prepare_qgraf_dat( 
        model::Model, 
        input::Dict{Any,Any} 
    )::Nothing

Prepare the model file for `QGRAF`.
"""
function prepare_qgraf_dat( 
    model::Model, 
    input::Dict{Any,Any} 
)::Nothing
#######################################################

  inc_part_list = map( s_ -> model.particle_name_dict[s_], input["incoming"] )
  inc_idx_str_list = map( i_ -> string(i_), eachindex(inc_part_list) )
  inc_mom_str_list = map( (i_,p_) -> is_massless(p_) ? "$(p_.name)[k$(i_)]" : "$(p_.name)[K$(i_)]", 
                          inc_idx_str_list, inc_part_list )

  n_inc = length(inc_part_list)
  out_part_list = map( s_ -> model.particle_name_dict[s_], input["outgoing"] )
  out_idx_str_list = map( i_ -> string(i_+n_inc), eachindex(out_part_list) )
  out_mom_str_list = map( (i_,p_) -> is_massless(p_) ? "$(p_.name)[k$(i_)]" : "$(p_.name)[K$(i_)]", 
                          out_idx_str_list, out_part_list )

  # In this file `loops` is chosen as `n_loop+QCDCT_order`
  #   because we implement the counterterm via tadpole loop of auxiliary field.
  file = open( "qgraf.dat", "w" )
  write( file, """
    output='qgraf_out.dat';
    style='miracle.sty';
    model='model.qgraf';
    in = $( join( inc_mom_str_list, "," ) );
    out = $( join( out_mom_str_list, "," ) );
    loops = $(input["n_loop"]+input["QCDCT_order"]);
    loop_momentum = q;
    """ )
  if input["DropTadpole"] == true && input["DropWFcorrection"] == true 
    write( file, 
    "options = notadpole, onshell;\n" )
  elseif input["DropTadpole"] == true && input["DropWFcorrection"] == false 
    write( file, 
    "options = notadpole;\n" )
  elseif input["DropTadpole"] == false && input["DropWFcorrection"] == true 
    write( file, 
    "options = onshell;\n" )
  else 
    write( file, 
    "options =;\n" )
  end # if
  write( file, """
    true = vsum[ gspow, $(input["Amp_QCD_order"]), $(input["Amp_QCD_order"])];
    true = vsum[ epow, $(input["Amp_QED_order"]), $(input["Amp_QED_order"])];
    true = vsum[ qcdct, $(input["QCDCT_order"]), $(input["QCDCT_order"])];
    true = vsum[ spc, $(input["Amp_SPC_order"]), $(input["Amp_SPC_order"])];
    """ )
  close(file)

  file = open( "miracle.sty", "w" )
  write( file, """
  <prologue>
  #
  # file generated by <program>
  #
  <command_loop><command_line_loop>#<command_data><end><end>#
  
  FeynmanDiagrams:
  <diagram>
  - # Diagram<diagram_index>
    diagram_index: <diagram_index>
    symmetry_factor: <symmetry_factor>
    n_loop: $(input["n_loop"])
    sign: <sign>1
    incoming_propagators:<in_loop>
      - # incoming particle <in_index>
        in_index: <in_index>
        vertex_index: <vertex_index>
        field: "<field>"
        field_index: <field_index>
        momentum: "<momentum>"<end>
    outgoing_propagators:<out_loop>
      - # outgoing particle <out_index>
        out_index: <out_index>
        vertex_index: <vertex_index>
        field: "<field>"
        field_index: <field_index>
        momentum: "<momentum>"<end>
    remnant_propagators:<propagator_loop> 
      - # internal or loop propagator <propagator_index>
        propagator_index: <propagator_index>
        birth_index: <dual-vertex_index>
        death_index: <vertex_index>
        field: "<field>"
        momentum: "<momentum>"<end>
    vertices:<vertex_loop>
      - # vertex <vertex_index>
        vertex_index: <vertex_index>
        momentum_product: [[<ray_loop>"(<momentum>)",<end><back>]]
        fields: [[<ray_loop>"<field>",<end><back>]]
        propagator_index_list: [[<ray_loop><propagator_index>,<end><back>]]<end>
  <epilogue>
  
  
  <exit>

  """)
  close(file)

  return nothing

end # function prepare_qgraf_dat


#######################################################################
"""
    generate_Feynman_diagram( 
        model::Model, 
        input::Dict{Any,Any} 
    )::Nothing

Interface to generating Feynman diagrams by using `QGRAF`.
"""
function generate_Feynman_diagram( 
    model::Model, 
    input::Dict{Any,Any} 
)::Nothing
#######################################################################

  printstyled( "[ Generate Feynman diagrams using QGRAF ]\n", color=:green )

  prepare_qgraf_dat( model, input )

  rm( "qgraf_out.dat"; force=true, recursive=true )
  run( pipeline( `$(qgraf())`, "qgraf.log" ) )
  @assert isfile( "qgraf_out.dat" )

  rm( "qgraf.dat" )
  rm( "qgraf.log" )
  rm( "model.qgraf" )
  rm( "miracle.sty" )

  return nothing

end # function generate_Feynman_diagram





#######################################################################
"""
    get_interaction( 
        field_name_list::Vector{String}, 
        model::Model 
    )::Tuple{Interaction,Int64}

Based on `model.particle_name_dict`, 
  get the interaction according to the link field name list.
"""
function get_interaction( 
    field_name_list::Vector{String}, 
    model::Model 
)::Tuple{Interaction,Int64}
########################################################################

  # QCDct_link_name_list = filter( s_ -> s_ in ["QCDct1","QCDct2"], field_name_list )
  # QCDct_order = length( QCDct_link_name_list )
  QCDct_order = begin
    QCDct_link_name_list = filter( s_->startswith(s_,"QCDct")&&(!endswith(s_,"bar")), field_name_list )
    @assert all( s_->(!isnothingâˆ˜findfirst)(r"^QCDct[1-9]\d*$",s_), QCDct_link_name_list )
    isempty(QCDct_link_name_list) ? 0 : sum( s_->parse(Int,match(r"[1-9]\d*",s_).match), QCDct_link_name_list )
  end # QCDct_order

  # normal_link_name_list = filter( s_ -> (s_ in ["QCDct1","QCDct2"]) == false, field_name_list )
  normal_link_name_list = filter( !contains("QCDct"), field_name_list ) 
  normal_link_kf_list = map( s_ -> model.particle_name_dict[s_].kf, normal_link_name_list )
  sorted_normal_link_kf_list = sort( normal_link_kf_list )
  inter = model.sorted_kf_list_dict[sorted_normal_link_kf_list]

  return inter, QCDct_order
end # function get_interaction




###################################################################
"""
    get_incoming_couplings_lorentz_list( 
        part::Particle, 
        mark::Int64, 
        momentum::Basic 
    )::Vector{Basic}

Produce the Basic expression for the incoming particles, 
  which can be spinors or polarization vectors.
"""
function get_incoming_couplings_lorentz_list( 
    part::Particle, 
    mark::Int64, 
    momentum::Basic 
)::Vector{Basic}
#####################################################################

  if part.spin == :fermion && part.kf > 0 
    return [ Basic(" SpU( $mark, spb$mark, $momentum, $(part.mass) ) ") ]
  elseif part.spin == :fermion && part.kf < 0
    return [ Basic(" SpVB( $mark, spb$mark, $momentum, $(part.mass) ) ") ]
  elseif part.spin == :vector
    return [ Basic(" VecEp( $mark, mub$mark, $momentum, $(part.mass) ) ") ]
  elseif part.spin == :scalar
    return [ Basic("1") ]
  else
    @assert false "We should have not considered ghost in external field."
  end # if

end # function get_incoming_couplings_lorentz_list







################################################################
"""
    get_outgoing_couplings_lorentz_list( 
        part::Particle, 
        mark::Int64, 
        momentum::Basic 
    )::Vector{Basic}

Produce the Basic expression for the outgoing particles, 
  which can be spinors or polarization vectors.
"""
function get_outgoing_couplings_lorentz_list( 
    part::Particle, 
    mark::Int64, 
    momentum::Basic 
)::Vector{Basic}
################################################################

  if part.spin == :fermion && part.kf > 0
    return [ Basic(" SpUB( $mark, spa$mark, $momentum, $(part.mass) ) ") ]
  elseif part.spin == :fermion && part.kf < 0
    return [ Basic(" SpV( $mark, spa$mark, $momentum, $(part.mass) ) ") ]
  elseif part.spin == :vector
    return [ Basic(" VecEpC( $mark, mua$mark, $momentum, $(part.mass) ) ") ]
  elseif part.spin == :scalar
    return [ Basic("1") ]
  else
    error( "We should have not considered ghost in external field.\n" )
  end # if

end # function get_outgoing_couplings_lorentz_list


###############################################################################
"""
    get_remnant_couplings_lorentz_list( 
        part::Particle, 
        mark::Int64, 
        momentum::Basic, 
        use_unitary_gauge::Bool 
    )::Vector{Basic}

Produce the Basic expression for the internal/loop propagator particles.
"""
function get_remnant_couplings_lorentz_list( 
    part::Particle, 
    mark::Int64, 
    momentum::Basic, 
    use_unitary_gauge::Bool 
)::Vector{Basic}
###################################################################################

  if part.spin == :fermion
    #return [ Basic(" I*( GAij(spb$mark,spa$mark,$momentum)+ONEij(spb$mark,spa$mark)*$(part.mass) )*Den($momentum,$(part.mass),$(part.width)) ") ]
    return [ Basic(" I*GAij(spb$mark,spa$mark,$momentum,$(part.mass))*Den($momentum,$(part.mass),$(part.width)) ") ]
  elseif part.spin == :vector && is_massless(part) == true 
    return [ Basic(" (-1)*I*LMT(mua$mark,mub$mark)*Den($momentum,0,0) ") ]
  elseif part.spin == :vector && is_massless(part) == false 
    if use_unitary_gauge == true 
      return [ Basic(" (-1)*I*Den($momentum,$(part.mass),$(part.width))*( LMT(mua$mark,mub$mark)-FV($momentum,mua$mark)*FV($momentum,mub$mark)*$(part.mass)^(-2) ) ") ]
    else
      return [ Basic(" (-1)*I*LMT(mua$mark,mub$mark)*Den($momentum,$(part.mass),$(part.width)) ") ]
    end # if
  elseif part.spin in [:scalar, :ghost]
    return [ Basic(" I*Den( $momentum, $(part.mass), $(part.width) ) ") ]
  else 
    error( "We should have not considered ghost in external field.\n" )
  end # if

end # function get_remnant_couplings_lorentz_list



#############################################################
"""
    edge_from_link_index( 
        vert_id::Int64, 
        link_index::Int64, 
        g::Graph 
    )::Edge

Get the Edge according to the link_index 
  in the vertex index `vert_id` in the Graph `g`.
"""
function edge_from_link_index( 
    g::Graph, 
    vert_id::Int64, 
    link_index::Int64  
)::Edge
##################################################################

  propagator_index = get_node_index_prop( g, vert_id, :propagator_index_list )[link_index]
  the_edge_pos = findfirst( e_ -> e_.property[:propagator_index] == propagator_index, g.edge_list )
  @assert the_edge_pos != nothing

  return g.edge_list[the_edge_pos]

end # function edge_from_link_index




#################################################################################
"""
    get_link_color( 
        g::Graph, 
        vert_id::Int64, 
        link_index::Int64, 
        part_list::Vector{Particle} 
    )::Basic

Generate the Basic expression symbol for the color index for the `link_index` 
  in vertex index `vert_id` in Graph `g`.
"""
function get_link_color( 
    g::Graph, 
    vert_id::Int64, 
    link_index::Int64, 
    part_list::Vector{Particle} 
)::Basic
################################################################################

  in_edge_list = get_in_edge_list( g, vert_id )
  out_edge_list = get_out_edge_list( g, vert_id )
  vert = g.node_list[vert_id]
  vert_mark = vert.property[:mark] 

  if link_index < 0
    link_color = Basic("clv$(vert_mark*100+abs(link_index))")
  else 
    link_edge = edge_from_link_index( g, vert_id, link_index )
    death_color = link_edge.property[:death_COLOR]
    birth_color = link_edge.property[:birth_COLOR]

    part = part_list[link_index]
    # This is for W+/W- like, although in SM there is only gluon will have this kind of color factor.
    link_color = link_edge in in_edge_list ? death_color : birth_color
    # Then what if gluon or Z-like
    if link_edge in in_edge_list && link_edge in out_edge_list 
      link_color = part.kf > 0 ? death_color : birth_color
      if is_neutral(part)
        propagator_index = vert.property[:propagator_index_list][link_index]
        first_pos = findfirst( x_ -> x_ == propagator_index,  vert.property[:propagator_index_list] )
        link_color = first_pos == link_index ? death_color : birth_color
      end # if
    end # if
  end # if 

  return link_color

end # function get_link_color


#########################################################################################
"""
    translate_color_factor( 
        one_color::Basic, 
        vert_id::Int64, 
        g::Graph, 
        part_list::Vector{Particle} 
)::Basic

Combine the generic color `one_color` expression with the specific node index `vert_id`, 
  and produce the color factor for this vertex in this diagram.
"""
function translate_color_factor( 
    one_color::Basic, 
    vert_id::Int64, 
    g::Graph, 
    part_list::Vector{Particle} 
)::Basic
#########################################################################################

  @funs Identity DeltaFun DeltaAdj T SUNT f SUNF

  color_str = string(one_color)
  new_color = one_color

  range_list = findall( r"Identity\([+-]*\d+, [+-]*\d+\)", color_str )
  Identity_str_list = map( r_ -> color_str[r_], range_list ) 

  for one_Identity_str in Identity_str_list 
    args = get_args( Basic(one_Identity_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])

    # It is not possible that both of link1_index and link2_index are negative (dummy).
    @assert link1_index > 0 || link2_index > 0 
    if link1_index > 0 
      edge1or2 = edge_from_link_index( g, vert_id, link1_index )
    elseif link2_index > 0
      edge1or2 = edge_from_link_index( g, vert_id, link2_index )
    else 
      @assert false
    end # if

    # This first case is considering the tadpole sunset diagram.
    if link1_index == link2_index
      color1, color2 = edge1or2.property["birth_COLOR"], edge1or2.property["death_COLOR"]
    # Then in the other case, we need to consider the case with dummy index.
    else
      color1 = get_link_color( g, vert_id, link1_index, part_list )
      color2 = get_link_color( g, vert_id, link2_index, part_list )
    end # if
    
    edge1or2_color = edge1or2.property[:particle].color
    @assert edge1or2_color != :singlet
    new_color = subs( new_color, Basic(one_Identity_str), 
                      edge1or2_color == :triplet ? DeltaFun(color1,color2) : DeltaAdj(color1,color2) )
  end # for one_Identity_str

  range_list = findall( r"[Tf]+\([+-]*\d+, [+-]*\d+, [+-]*\d+\)", color_str )
  Tf_str_list = map( r_ -> color_str[r_], range_list ) 

  for one_Tf_str in Tf_str_list 
    args = get_args( Basic(one_Tf_str) )
    link1_index, link2_index, link3_index = convert(Int64,args[1]), convert(Int64,args[2]), convert(Int64,args[3])

    # It is not possible that all of link1_index and link2_index and link3_index are negative (dummy).
    @assert link1_index > 0 || link2_index > 0 || link3_index > 0

    # two of [link1_index,link2_index,link3_index] are same 
    if link1_index == link2_index
      edge12 = edge_from_link_index( g, vert_id, link1_index )
      color1, color2 = edge12.property[:birth_COLOR], edge12.property[:death_COLOR]
      color3 = get_link_color( g, vert_id, link3_index, part_list )
    elseif link1_index == link3_index
      edge13 = edge_from_link_index( g, vert_id, link1_index )
      color1, color3 = edge13.property[:birth_COLOR], edge13.property[:death_COLOR]
      color2 = get_link_color( g, vert_id, link2_index, part_list )
    elseif link2_index == link3_index
      edge23 = edge_from_link_index( g, vert_id, link2_index )
      color2, color3 = edge23.property[:birth_COLOR], edge23.property[:death_COLOR]
      color1 = get_link_color( g, vert_id, link1_index, part_list )
    # Then none of them are same.
    else
      color1 = get_link_color( g, vert_id, link1_index, part_list )
      color2 = get_link_color( g, vert_id, link2_index, part_list )
      color3 = get_link_color( g, vert_id, link3_index, part_list )
    end # if
    
    new_color = subs( new_color, Basic(one_Tf_str), 
                                 Basic("SUN$(uppercase(one_Tf_str[1]))($color1,$color2,$color3)") )
  end # for one_T_str

  return new_color
end # function translate_color_factor



#####################################################################
"""
    get_link_lorentz( 
        g::Graph, 
        vert_id::Int64, 
        link_index::Int64, 
        part_list::Vector{Particle} 
    )::Basic

Generate the Basic expression symbol for the Lorentz index 
  for the `link_index` in node_index `vert_id` in Graph `g`.
"""
function get_link_lorentz( 
    g::Graph, 
    vert_id::Int64, 
    link_index::Int64, 
    part_list::Vector{Particle} 
)::Basic
####################################################################

  in_edge_list = get_in_edge_list( g, vert_id )
  out_edge_list = get_out_edge_list( g, vert_id )
  vert = g.node_list[vert_id]
  vert_mark = vert.property[:mark]

  if link_index < 0
    link_lor = Basic("muv$(vert_mark*100+abs(link_index))")
  else 
    link_edge = edge_from_link_index( g, vert_id, link_index )
    death_lor = link_edge.property[:death_LORENTZ]
    birth_lor = link_edge.property[:birth_LORENTZ]

    part = part_list[link_index]
    # This is for W+/W-
    link_lor = link_edge in in_edge_list ? death_lor : birth_lor
    # Then what if gluon or Z
    if link_edge in in_edge_list && link_edge in out_edge_list
      link_lor = part.kf > 0 ? death_lor : birth_lor
      if is_neutral(part)
        propagator_index = vert.property[:propagator_index_list][link_index]
        first_pos = findfirst( x_ -> x_ == propagator_index,  vert.property[:propagator_index_list] )
        link_lor = first_pos == link_index ? death_lor : birth_lor
      end # if
    end # if
  end # if 

  return link_lor

end # function get_link_lorentz


#######################################################################################
"""
    get_link_momentum( g::Graph, vert_id::Int64, link_index::Int64 )::Basic

Generate the Basic expression symbol for the momentum 
  for the `link_index` in node index `vert_id` in Graph `g`.
"""
function get_link_momentum( g::Graph, vert_id::Int64, link_index::Int64 )::Basic
#######################################################################################

  in_edge_list = get_in_edge_list( g, vert_id )

  @assert link_index > 0
  link_edge = edge_from_link_index( g, vert_id, link_index )
  # momentum is flow out in UFO Feynman rules
  link_momentum = ( link_edge in in_edge_list ? (-1) : 1 ) * link_edge.property[:momentum]

  return link_momentum

end # function get_link_momentum



#####################################################################################
"""
    get_link_spinor( g::Graph, vert_id::Int64, link_index::Int64 )::Basic

Generate the Basic expression symbol for the external spinors for the `link_index` 
  in node index `vert_id` in Graph `g`.
"""
function get_link_spinor( g::Graph, vert_id::Int64, link_index::Int64 )::Basic
#####################################################################################

  in_edge_list = get_in_edge_list( g, vert_id )
  vert = g.node_list[vert_id]
  vert_mark = vert.property[:mark]

  if link_index < 0
    link_spinor = Basic("spv$(vert_mark*100+abs(link_index))")
  else 
    link_edge = edge_from_link_index( g, vert_id, link_index )
    link_spinor = link_edge in in_edge_list ? link_edge.property[:death_SPINOR] : link_edge.property[:birth_SPINOR]
  end # if 

  return link_spinor

end # function get_link_spinor





############################################################################
"""
    translate_lorentz_factor( 
        one_lorentz::Basic, 
        vert_id::Int64, 
        g::Graph, 
        part_list::Vector{Particle} 
    )::Basic

Combine the generic Lorentz factor `one_lorentz` expression 
  with the specific node index `vert_id`, and produce the Lorentz factor 
  for this vertex in this diagram.
"""
function translate_lorentz_factor( 
    one_lorentz::Basic, 
    vert_id::Int64, 
    g::Graph, 
    part_list::Vector{Particle} 
)::Basic
##############################################################################

  @funs Metric LMT P FV Gamma GAij ProjP PRij ProjM PLij Identity ONEij 

  if one_lorentz == P(1, 2)*Metric(2, 3) - P(1, 3)*Metric(2, 3) - P(2, 1)*Metric(1, 3) + P(2, 3)*Metric(1, 3) + P(3, 1)*Metric(1, 2) - P(3, 2)*Metric(1, 2)
    edge1 = edge_from_link_index( g, vert_id, 1 )
    edge2 = edge_from_link_index( g, vert_id, 2 )
    edge3 = edge_from_link_index( g, vert_id, 3 )
    lor1 = get_link_lorentz( g, vert_id, 1, part_list )
    lor2 = get_link_lorentz( g, vert_id, 2, part_list )
    lor3 = get_link_lorentz( g, vert_id, 3, part_list )
    mom1 = get_link_momentum( g, vert_id, 1 )
    mom2 = get_link_momentum( g, vert_id, 2 )
    mom3 = get_link_momentum( g, vert_id, 3 )
    new_lorentz = FV(mom2-mom3,lor1)*LMT(lor2,lor3) + FV(mom3-mom1,lor2)*LMT(lor3,lor1) + FV(mom1-mom2,lor3)*LMT(lor1,lor2)
    return new_lorentz
  end # if

  lorentz_str = string(one_lorentz)
  new_lorentz = one_lorentz

  range_list = findall( r"Metric\([+-]*\d+, [+-]*\d+\)", lorentz_str )
  Metric_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_Metric_str in Metric_str_list
    args = get_args( Basic(one_Metric_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])
    @assert link1_index > 0 && link2_index > 0
    if link1_index > 0 
      edge1or2 = edge_from_link_index( g, vert_id, link1_index )
    elseif link2_index > 0
      edge1or2 = edge_from_link_index( g, vert_id, link2_index )
    else 
      @assert false
    end # if

    if link1_index == link2_index
      lor1, lor2 = edge1or2.property[:birth_LORENTZ], edge1or2.property[:death_LORENTZ]
    else
      lor1 = get_link_lorentz( g, vert_id, link1_index, part_list )
      lor2 = get_link_lorentz( g, vert_id, link2_index, part_list )
    end # if

    new_lorentz = subs( new_lorentz, Basic(one_Metric_str), LMT(lor1,lor2) )
  end # for one_Metric_str

  range_list = findall( r"P\([+-]*\d+, [+-]*\d+\)", lorentz_str )
  P_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_P_str in P_str_list
    args = get_args( Basic(one_P_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])

    lor1 = get_link_lorentz( g, vert_id, link1_index, part_list )
    mom2 = get_link_momentum( g, vert_id, link2_index )
    new_lorentz = subs( new_lorentz, Basic(one_P_str), FV(mom2,lor1) )
  end # for one_P_str

  range_list = findall( r"Gamma\([+-]*\d+, [+-]*\d+, [+-]*\d+\)", lorentz_str )
  Gamma_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_Gamma_str in Gamma_str_list
    args = get_args( Basic(one_Gamma_str) )
    link1_index, link2_index, link3_index = convert(Int64,args[1]), convert(Int64,args[2]), convert(Int64,args[3])

    lor1 = get_link_lorentz( g, vert_id, link1_index, part_list )
    sp2 = get_link_spinor( g, vert_id, link2_index )
    sp3 = get_link_spinor( g, vert_id, link3_index )

    new_lorentz = subs( new_lorentz, Basic(one_Gamma_str), GAij(sp2,sp3,lor1) )
  end # for one_Gamma_str

  range_list = findall( r"ProjP\([+-]*\d+, [+-]*\d+\)", lorentz_str )
  ProjP_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_ProjP_str in ProjP_str_list
    args = get_args( Basic(one_ProjP_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])

    sp1 = get_link_spinor( g, vert_id, link1_index )
    sp2 = get_link_spinor( g, vert_id, link2_index )

    new_lorentz = subs( new_lorentz, Basic(one_ProjP_str), PRij(sp1,sp2) )
  end # for one_ProjP_str

  range_list = findall( r"ProjM\([+-]*\d+, [+-]*\d+\)", lorentz_str )
  ProjM_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_ProjM_str in ProjM_str_list
    args = get_args( Basic(one_ProjM_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])

    sp1 = get_link_spinor( g, vert_id, link1_index )
    sp2 = get_link_spinor( g, vert_id, link2_index )

    new_lorentz = subs( new_lorentz, Basic(one_ProjM_str), PLij(sp1,sp2) )
  end # for one_ProjM_str

  range_list = findall( r"Identity\([+-]*\d+, [+-]*\d+\)", lorentz_str )
  Identity_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_Identity_str in Identity_str_list
    args = get_args( Basic(one_Identity_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])

    sp1 = get_link_spinor( g, vert_id, link1_index )
    sp2 = get_link_spinor( g, vert_id, link2_index )

    new_lorentz = subs( new_lorentz, Basic(one_Identity_str), ONEij(sp1,sp2) )
  end # for one_Identity_str

  return new_lorentz

end # function translate_lorentz_factor









###########################################################################
"""
    convert_qgraf_TO_Graph( 
        one_qgraf::Dict{Any,Any}, 
        model::Model 
    )::Union{Graph,Nothing}

Convert the diagram read from QGRAF into the Graph in Julia.
"""
function convert_qgraf_TO_Graph( 
    one_qgraf::Dict{Any,Any}, 
    model::Model 
)::Union{Graph,Nothing}
###########################################################################

  # Check if there is CT vertex and if the QCDct field is properly used for CT graphs.
  # QCDct1 and QCDct2 should have same end-points as designed.
  # It is possible that the diagram does not have any remnant propagator.
  QCDct_propagators = Dict{Any,Any}[]
  if !isnothing( one_qgraf["remnant_propagators"] )
    QCDct_propagators::Array{Dict{Any,Any},1} = filter( p_ -> p_["field"] in ["QCDct1","QCDct2"], one_qgraf["remnant_propagators"] )
    invalid_propagator_pos = findfirst( p_ -> p_["birth_index"] != p_["death_index"], QCDct_propagators )
    if !isnothing( invalid_propagator_pos ) 
      @info "Found one invalid diagram!"
      return nothing
    end # if
  end # if

  n_QCDct = length( QCDct_propagators )

  qgraf_incoming_propagators = one_qgraf["incoming_propagators"]
  n_inc = length(qgraf_incoming_propagators)
  qgraf_outgoing_propagators = one_qgraf["outgoing_propagators"]
  n_out = length(qgraf_outgoing_propagators)

  g = graph()  
  set_prop!( g, Dict{Symbol,Any}( 
    ## Diagram index
    :diagram_index => one_qgraf["diagram_index"], 
    ## Read-in symmetry_factor.
    :symmetry_factor => one_qgraf["symmetry_factor"], 
    ## Read-in sign of this diagram. 
    ## The sign from QGRAF is combination of anti-commutivative field (fermion,ghost,QCDct1,QCDct2...) loops,
    ##   and the way open fermionic/ghost lines connect those external fields.
    ## Also correct the sign if there is QCDct1 or QCDct2, 
    ##   since they are defined as anti-commutative fields to avoid changing symmetry factor.
    :sign => one_qgraf["sign"]*(-1)^n_QCDct, 
    :n_loop => one_qgraf["n_loop"], 
    ## For distinguishing incoming and outgoing edges
    :n_inc => n_inc, 
    :n_out => n_out 
  ) )



  ## Add incoming vertices.
  for one_inc in qgraf_incoming_propagators
    vert_idx = n_node(g)+1 # vert_idx starts from 1
    mark = one_inc["in_index"] 
    add_node!( g, mark, Dict{Symbol,Any}(
      :name => "v$vert_idx", 
      :mark => mark,
      :style => "External",
      :interaction => nothing,
      :QCDct_order => 0,
      :color_list => [1],
      :couplings_lorentz_list => [1]
    ) )
  end # for one_inc


  # Add outgoing vertices.
  for one_out in qgraf_outgoing_propagators
    vert_idx = n_node(g)+1 # vert_idx starts from 1
    mark = one_out["out_index"]+n_inc 
    add_node!( g, mark, Dict{Symbol,Any}(
      :name => "v$vert_idx",
      :mark => mark,
      :style => "External",
      :interaction => nothing,
      :QCDct_order => 0,
      :color_list => [1],
      :couplings_lorentz_list => [1] 
    ) ) 
  end # for one_out


  #  Add internal or loop vertices.
  qgraf_vertices = one_qgraf["vertices"]
  for one_vert in qgraf_vertices
    # Get interaction and QCDct_order
    inter, QCDct_order = get_interaction( one_vert["fields"], model )
    
    #-----------------------------------------------------------------------------------------------
    # Now we need to re-order the list "propagator_index_list" associated with one_vert["fields"] (source)
    #     according to the vertex Feynman rule "inter.link_list" (destination).
    #-----------------------------------------------------------------------------------------------
    src_part_name_list = filter( !contains("QCDct"), one_vert["fields"] ) # source list of particle names
    p_src = sortperm( src_part_name_list )
    dst_part_name_list = map( p_ -> p_.name, inter.link_list ) # destination list of particle names
    p_dst = sortperm( dst_part_name_list )
    invp_dst = invperm( p_dst )
    @assert src_part_name_list[p_src][invp_dst] == dst_part_name_list
    feynrules_index_list = one_vert["propagator_index_list"][p_src][invp_dst] 

    # color_list and couplings_lorentz_list will be generated later.
    vert_idx = n_node(g)+1 # vert_idx starts from 1
    mark = one_vert["vertex_index"]+n_inc+n_out 
    add_node!( g, mark, Dict{Symbol,Any}(
      :name => "v$vert_idx", 
      :mark => mark,
      :style => "Internal",
      :interaction => inter,
      :QCDct_order => QCDct_order,
      :propagator_index_list => feynrules_index_list,
      :color_list => nothing,
      :couplings_lorentz_list => nothing 
    ) )
  end # for one_vert


  # Add incoming propagators.
  # It could be u(kf>0) or vbar(kf<0) for fermion, epsilon_\mu for vector, 1 for scalar.
  for one_inc in qgraf_incoming_propagators
    in_v_mark = one_inc["in_index"]
    vert_v_mark = one_inc["vertex_index"]+n_inc+n_out
    field_name = one_inc["field"]
    field_part = model.particle_name_dict[field_name]

    mark = in_v_mark
    momentum = Basic(one_inc["momentum"])
    couplings_lorentz_list = get_incoming_couplings_lorentz_list( field_part, mark, momentum )

    add_edge!( g, mark, in_v_mark, vert_v_mark, Dict{Symbol,Any}( 
        :mark => mark,
        :particle => field_part,
        :style => "External",
        :propagator_index => one_inc["field_index"],
        :momentum => momentum,
        :null_MOM => Basic("k$mark"),
        :birth_LORENTZ => Basic("mua$mark"), 
        :birth_COLOR => Basic("cla$mark"), 
        :birth_SPINOR => Basic("spa$mark"),
        :death_LORENTZ => Basic("mub$mark"), 
        :death_COLOR => Basic("clb$mark"), 
        :death_SPINOR => Basic("spb$mark"),
        :color_list => [ Basic("1") ],
        :couplings_lorentz_list => couplings_lorentz_list 
    ) ) 
  end # for one_inc


  # Add outgoing propagaotrs.
  # It could be ubar(kf>0) or v(kf<0) for fermion, epsilon_\mu^* for vector, 1 for scalar.
  for one_out in qgraf_outgoing_propagators
    out_v_mark = one_out["out_index"]+n_inc
    vert_v_mark = one_out["vertex_index"]+n_inc+n_out
    field_name = one_out["field"]
    field_part = model.particle_name_dict[field_name]

    mark = out_v_mark
    momentum = Basic(one_out["momentum"])
    couplings_lorentz_list = get_outgoing_couplings_lorentz_list( field_part, mark, momentum )

    add_edge!( g, mark, vert_v_mark, out_v_mark, Dict{Symbol,Any}( 
        :mark => mark,
        :particle => field_part,
        :style => "External",
        :propagator_index => one_out["field_index"],
        :momentum => momentum,
        :null_MOM => Basic("k$mark"),
        :birth_LORENTZ => Basic("mua$mark"), 
        :birth_COLOR => Basic("cla$mark"), 
        :birth_SPINOR => Basic("spa$mark"),
        :death_LORENTZ => Basic("mub$mark"), 
        :death_COLOR => Basic("clb$mark"), 
        :death_SPINOR => Basic("spb$mark"),
        :color_list => [ Basic("1") ],
        :couplings_lorentz_list => couplings_lorentz_list 
    ) ) 
  end # for one_out


  # Filter out the "QCDct1" and "QCDct2" propagators.
  # It is possible that the diagram does not have any remnant propagator.
  true_remnant_propagators = Dict{Any,Any}[]
  if !isnothing( one_qgraf["remnant_propagators"] )
    qgraf_remnant_propagators = one_qgraf["remnant_propagators"]
    true_remnant_propagators::Array{Dict{Any,Any},1} = filter( rem_ -> (rem_["field"] in ["QCDct1","QCDct2"]) == false, qgraf_remnant_propagators )
  end # if
  # Add internal and loop propagators.
  for one_rem in true_remnant_propagators
    mark = one_rem["propagator_index"]+n_inc+n_out
    birth_v_mark = one_rem["birth_index"]+n_inc+n_out
    death_v_mark = one_rem["death_index"]+n_inc+n_out
    field_name = one_rem["field"]
    field_part = model.particle_name_dict[field_name]

    momentum = sign(field_part.kf)*Basic(one_rem["momentum"])

    style_str = findfirst("q",one_rem["momentum"]) == nothing ? "Internal" : "Loop"

    id_color_dict = Dict( :triplet => [ Basic(" DeltaFun(clb$mark,cla$mark) ") ], 
                          :octet   => [ Basic(" DeltaAdj(clb$mark,cla$mark) ") ],
                          :singlet => [ Basic("1") ] )

    couplings_lorentz_list = get_remnant_couplings_lorentz_list( field_part, mark, momentum, model.unitary_gauge )

    new_edge_pair = field_part.kf > 0 ? ( birth_v_mark, death_v_mark ) : ( death_v_mark, birth_v_mark )

    add_edge!( g, mark, new_edge_pair, Dict{Symbol,Any}( 
      :mark => mark,
      :particle => model.particle_kf_dict[abs(field_part.kf)],
      :style => style_str,
      :propagator_index => one_rem["propagator_index"], 
      :momentum => momentum,
      :null_MOM => Basic("0"),
      :birth_LORENTZ => Basic("mua$mark"), 
      :birth_COLOR => Basic("cla$mark"), 
      :birth_SPINOR => Basic("spa$mark"),
      :death_LORENTZ => Basic("mub$mark"), 
      :death_COLOR => Basic("clb$mark"), 
      :death_SPINOR => Basic("spb$mark"),
      :color_list => id_color_dict[field_part.color],
      :couplings_lorentz_list => couplings_lorentz_list 
    ) ) 
  end # for one_rem



  #-------------------------------------------------------------------
  # Now the structure of this Feynman diagram has been digested into Graph.
  # Then we can evaluate color_row_list and couplings_lorentz_col_list for the internal or loop vertices.
  #-------------------------------------------------------------------
  internal_vertex_index_list = filter( v_id -> get_node_index_prop(g,v_id,:style) == "Internal", 1:n_node(g) )
  for vert_id in internal_vertex_index_list
    vert = g.node_list[vert_id]
    inter = vert.property[:interaction]

    new_color_row_list = map( color_ -> translate_color_factor(color_,vert_id,g,inter.link_list), 
                              inter.color_row_list )

    new_lorentz_col_list = map( lor_ -> translate_lorentz_factor(lor_,vert_id,g,inter.link_list), 
                                inter.lorentz_col_list )

    n_row, n_col = size( inter.couplings_matrix )
    new_couplings_lorentz_list = Array{Basic,1}(undef,n_row)
    @vars CTorder
    for r_ in 1:n_row
      new_couplings_lorentz_list[r_] = 0
      for c_ in 1:n_col
        if vert.property[:QCDct_order] == 0 
          new_couplings_lorentz_list[r_] += subs(inter.couplings_matrix[r_,c_],CTorder,0)*new_lorentz_col_list[c_]
        else 
          new_couplings_lorentz_list[r_] += SymEngine.coeff( expand(inter.couplings_matrix[r_,c_]), CTorder^(vert.property[:QCDct_order]) )*new_lorentz_col_list[c_]
        end # if
      end # for c_
    end # for r_

    vert.property[:color_list] = new_color_row_list
    vert.property[:couplings_lorentz_list] = new_couplings_lorentz_list
  end # for vert 

  return g

end # function convert_qgraf_TO_Graph





###################################################################
"""
    assemble_amplitude( g::Graph )::Tuple{Vector{Basic},Vector{Basic}}

Now this graph can be evaluated according to the values of the propagators and vertices.
"""
function assemble_amplitude( g::Graph )::Tuple{Vector{Basic},Vector{Basic}}
###################################################################

  amp_color_list = Basic[1]
  amp_couplings_lorentz_list = Basic[1]
  for vert in g.node_list
    # amp_color_list = tensor_product( amp_color_list, vert.property[:color_list] )
    # amp_couplings_lorentz_list = tensor_product( amp_couplings_lorentz_list, vert.property[:couplings_lorentz_list] )
    amp_color_list = vectorized_tensor_product_Basic( amp_color_list, vert.property[:color_list] )
    amp_couplings_lorentz_list = vectorized_tensor_product_Basic( amp_couplings_lorentz_list, vert.property[:couplings_lorentz_list] )
  end # for vert

  for edge in g.edge_list
    # amp_color_list = tensor_product( amp_color_list, edge.property[:color_list] )
    # amp_couplings_lorentz_list = tensor_product( amp_couplings_lorentz_list, edge.property[:couplings_lorentz_list] )
    amp_color_list = vectorized_tensor_product_Basic( amp_color_list, edge.property[:color_list] )
    amp_couplings_lorentz_list = vectorized_tensor_product_Basic( amp_couplings_lorentz_list, edge.property[:couplings_lorentz_list] )
  end # for edge

  return amp_color_list, amp_couplings_lorentz_list;

end # function assemble_amplitude




###############################################################
"""
    generate_scale2_list( g::Graph, kin_relation::Dict{Basic,Basic} )::Vector{Basic}

Collect all the symbols that are the squares of scales.
"""
function generate_scale2_list( g::Graph, kin_relation::Dict{Basic,Basic} )::Vector{Basic}
###############################################################

  ver_mass_list = Vector{Basic}()
  #-----------------------
  for one_pair in kin_relation
    if get_name( one_pair[1] ) == "Den"
      continue
    end # if
    ver_mass_list = vcat( ver_mass_list, free_symbols( one_pair[2] ) )
  end # for one_pair

  #-----------------------
  for one_edge in g.edge_list
    mass = one_edge.property[:particle].mass
    if mass == 0
      continue
    end # if
    ver_mass_list = vcat( ver_mass_list, mass )
  end # for one_edge

  #-----------------------
  unique!( ver_mass_list )


  #-----------------------
  scale2_list = Vector{Basic}( undef, length(ver_mass_list) )
  for index in 1:length(ver_mass_list)
    ver_mass_str = string(ver_mass_list[index])
    if ver_mass_str[1] == 'm'
      scale2_list[index] = ver_mass_list[index]^2
    else 
      scale2_list[index] = ver_mass_list[index]
    end # if
  end # for index

  return scale2_list

end # function generate_scale2_list













#######################################################################
"""
    factor_out_loop_den( 
        g::Graph, 
        lorentz_list::Vector{Basic} 
    )::Tuple{Vector{Basic},Vector{Basic},Vector{Int64}}

Factorize out the loop propagator denominators, 
  so that the `lorentz_list` can become shorter. 
  And then they can be handled separately.
"""
function factor_out_loop_den( 
    g::Graph, 
    lorentz_list::Vector{Basic}, 
    mom_conserv::Pair{Basic,Basic} 
)::Tuple{Vector{Basic},Vector{Basic},Vector{Int64}}
#########################################################################

  @funs Den

  loop_edge_list = filter( x -> x.property[:style] == "Loop", g.edge_list )

  den_prod = one(Basic)
  width_den_prod = one(Basic)
  for one_edge in loop_edge_list
    mom = one_edge.property[:momentum]
    mass = one_edge.property[:particle].mass
    width = one_edge.property[:particle].width
    # For now we only consider the width of loop propagator is zero.
    new_mom = (normalize_loop_mom_singleâˆ˜subs)(mom,mom_conserv)
    den_prod *= Den( new_mom, mass, 0 ) 
    width_den_prod *= Den( mom, mass, width ) 
  end # for one_edge

  new_lorentz_list = map( x -> expand(x/width_den_prod), lorentz_list )

  @assert is_class(:Mul,den_prod) || den_prod == 1 || get_name(den_prod) == "Den"
  factor_list = get_args(den_prod)
  if is_FunctionSymbol(den_prod) && get_name(den_prod) == "Den" 
    factor_list = Basic[ den_prod ]
  end # if
  n_factor = length(factor_list)
  loop_den_list = Vector{Basic}( undef, n_factor )
  loop_den_xpt_list = Vector{Int64}( undef, n_factor )
  for index in 1:n_factor
    one_factor = factor_list[index]
    if is_FunctionSymbol(one_factor) && get_name(one_factor) == "Den"
      loop_den_list[index] = one_factor
      loop_den_xpt_list[index] = 1
    elseif is_class(:Pow,one_factor) && (get_nameâˆ˜firstâˆ˜get_args)(one_factor) == "Den"
      loop_den_list[index] = (firstâˆ˜get_args)(one_factor)
      loop_den_xpt_list[index] = convert( Int64, get_args(one_factor)[2] )
    else
      error( "Not expected: $(one_factor)" )
    end # if
  end # for index

  return new_lorentz_list, loop_den_list, loop_den_xpt_list

end # function factor_out_loop_den











##################################################################################
# Changed by Quan-feng WU (wuquanfeng@ihep.ac.cn)
# March 9, 2023
"""
    contract_Dirac_indices_noexpand( 
        g::Graph, 
        graph_index::Int64, 
        lorentz_expr_list::Vector{Basic} 
    )::Vector{Basic}

Contract the Dirac indices in the `lorentz_expr_list` by using FORM scripts, 
  but do not expand the amplitudes.
"""
function contract_Dirac_indices_noexpand( 
    g::Graph, 
    graph_index::Int64, 
    lorentz_expr_list::Vector{Basic} 
)::Vector{Basic}
##################################################################################

  printstyled( "\n[ Contract the Dirac indices for diagram #$(graph_index) ]\n", color=:green )

  new_lorentz_expr_list = Vector{Basic}( undef, length(lorentz_expr_list) )

  cost_time = @elapsed begin
  for index in 1:length(lorentz_expr_list)
    lorentz_expr = lorentz_expr_list[index]
    file_name = "contract_lorentz_expr$(index)_diagram$(graph_index)_noexpand"
    form_script_str = make_amp_contraction_noexpand_script( lorentz_expr )

    result_io = IOBuffer()

    println( "  [ form $(file_name).frm ]" )
    try
      run( pipeline( `$(tform()) -w$(Threads.nthreads()) -q -`; stdin=IOBuffer(form_script_str), stdout=result_io ) )
    catch
      write( "$(file_name).frm", form_script_str )
      rethrow()
    end

    result_expr = (Basicâˆ˜Stringâˆ˜take!)(result_io)
    new_lorentz_expr_list[index] = result_expr

  end # for index
  end # cost_time
  println( "<$(cost_time) sec>" )

  return new_lorentz_expr_list

end # function contract_Dirac_indices_noexpand











#########################################################
# Changed by Quan-feng WU (wuquanfeng@ihep.ac.cn)
# March 9, 2023
"""
    simplify_color_factors( 
        g::Graph, 
        graph_index::Int64, 
        color_factor_list::Vector{Basic} 
    )::Vector{Basic}

Simplify the color factors by using FORM scripts.
"""
function simplify_color_factors( 
    g::Graph, 
    graph_index::Int64, 
    color_factor_list::Vector{Basic} 
)::Vector{Basic}
#########################################################

  printstyled( "\n[ Simplify the color factor for diagram #$(graph_index) ]\n", color=:green )

  new_color_factor_list = Vector{Basic}( undef, length(color_factor_list) )

  cost_time = @elapsed begin
  for index in eachindex(color_factor_list)
    one_color_factor = color_factor_list[index]
    file_name = "simplify_color$(index)_diagram$(graph_index)"
    form_script_str = make_color_script( one_color_factor )

    result_io = IOBuffer()

    println( "  [ form $(file_name).frm ]" )
    try
      run( pipeline( `$(form()) -q -`; stdin=IOBuffer(form_script_str), stdout=result_io ) )
    catch
      write( "$(file_name).frm", form_script_str )
      rethrow()
    end

    result_expr = (Basicâˆ˜Stringâˆ˜take!)(result_io)
    new_color_factor_list[index] = result_expr

  end # for index
  end # cost_time
  println( "<$(cost_time) sec>" )

  return new_color_factor_list

end # function simplify_color_factors



########################################################################################
"""
    write_out_amplitude( 
        n_inc::Int64, 
        n_loop::Int64, 
        graph_index::Int64, 
        couplingfactor::Basic, 
        parameter_dict::Dict{Basic,Basic}, 
        ext_mom_list::Vector{Basic}, 
        scale2_list::Vector{Basic}, 
        kin_relation::Dict{Basic,Basic}, 
        baseINC_script_str::String, 
        amp_color_list::Vector{Basic}, 
        amp_lorentz_noexpand_list::Vector{Basic}, 
        loop_den_list::Vector{Basic}, 
        loop_den_xpt_list::Vector{Int64}, 
        min_ep_xpt::Int64, 
        max_ep_xpt::Int64, 
        proc_str::String )::Nothing

Write out the amplitude information into the file that can be read easily.
"""
function write_out_amplitude( 
    n_inc::Int64, 
    n_loop::Int64, 
    graph_index::Int64, 
    couplingfactor::Basic, 
    parameter_dict::Dict{Basic,Basic}, 
    ext_mom_list::Vector{Basic}, 
    scale2_list::Vector{Basic}, 
    kin_relation::Dict{Basic,Basic}, 
    baseINC_script_str::String, 
    amp_color_list::Vector{Basic}, 
    amp_lorentz_noexpand_list::Vector{Basic}, 
    loop_den_list::Vector{Basic}, 
    loop_den_xpt_list::Vector{Int64},
    symmetry_map::Dict{Basic,Basic}, 
    min_ep_xpt::Int64, 
    max_ep_xpt::Int64, 
    proc_str::String
)::Nothing
###############################################################################################


  printstyled( "\n[ Generate amp$(graph_index).out ]\n", color=:green )
  amp_file = open( "$(proc_str)_amplitudes/amp$(graph_index).out", "w" )
  write( amp_file, """
    n_loop: $(n_loop)
    couplingfactor: $(couplingfactor)
    ext_mom_list: $(ext_mom_list)
    scale2_list: $(scale2_list)
    Graph #$(graph_index): 
      Denominators: 
    """ )
  for one_den in loop_den_list
    write( amp_file, 
    "    $(one_den)\n" )
  end # for one_den

  write( amp_file, 
    "Kinematics Relations: \n" )
  for one_pair in kin_relation
    write( amp_file, 
    "  $(one_pair)\n" )
  end # for one_pair

  write( amp_file, 
    "Symmetry Configuration: \n" )
  for one_pair in collect(symmetry_map)
    write( amp_file, 
    "  $(one_pair)\n" )
  end # for one_pair

  write( amp_file, 
    "Color Factors: \n" )
  for ii in 1:length(amp_color_list)
    one_color = amp_color_list[ii]
    write( amp_file, 
    "  amp_color #$(ii): \n"*
    "    $(one_color); \n" )
  end # for ii

  amp_lorentz_str_list = Vector{String}()
  write( amp_file, 
    "Lorentz Factors: \n" )
  for ii in 1:length(amp_lorentz_noexpand_list)
    one_val = amp_lorentz_noexpand_list[ii]
    amp_str = (stringâˆ˜expand)(one_val/couplingfactor)
    amp_str = replace( amp_str, "Coeff" => "" )
    amp_str = replace( amp_str, r"\s"=>"" )
    push!( amp_lorentz_str_list, amp_str )

    write( amp_file, 
    "  amp_lorentz #$(ii): \n"* 
    "    $(amp_str); \n" )
  end # for ii

  write( amp_file, 
    "Model Parameters: \n" )
  for one_pair in parameter_dict
    write( amp_file, 
    "  $(one_pair)\n" )
  end # for one_pair

  close( amp_file )

  if isfile( "$(proc_str)_amplitudes/amp$(graph_index).jld2" )
    rm( "$(proc_str)_amplitudes/amp$(graph_index).jld2" )
  end # if



  jldopen( "$(proc_str)_amplitudes/amp$(graph_index).jld2", "w" ) do file 
    write( file, "Generator", "FeAmGen.jl" )
    write( file, "n_inc", n_inc )
    write( file, "n_loop", n_loop )
    write( file, "min_ep_xpt", min_ep_xpt )
    write( file, "max_ep_xpt", max_ep_xpt )
    write( file, "couplingfactor", string(couplingfactor) )
    write( file, "ext_mom_list", string.(ext_mom_list) )
    write( file, "scale2_list", string.(scale2_list) )
    write( file, "loop_den_list",  string.(loop_den_list) )
    write( file, "loop_den_xpt_list", loop_den_xpt_list )
    write( file, "kin_relation", to_String_dict(kin_relation) )
    write( file, "baseINC_script_str", baseINC_script_str )
    write( file, "symmetry_map", to_String_dict(symmetry_map) ) 
    write( file, "model_parameter_dict", to_String_dict(parameter_dict) ) 
    write( file, "amp_color_list",  string.(amp_color_list) )
    write( file, "amp_lorentz_list",  amp_lorentz_str_list )
  end # file

  return nothing

end # function write_out_amplitude












#########################################################################
"""
    write_out_visual_graph( 
        g::Graph, 
        graph_index::Int64, 
        model::Model, 
        couplingfactor::Basic, 
        color_list::Vector{Basic}, 
        lorentz_list::Vector{Basic}, 
        loop_den_list::Vector{Basic}, 
        loop_den_xpt_list::Vector{Int64}, 
        ext_mom_list::Vector{Basic}, 
        scale2_list::Vector{Basic}, 
        symmetry_map::Dict{Basic,Basic}, 
        proc_str::String 
    )::Nothing

Write out the diagrams into the file that can be complied or read easily.
"""
function write_out_visual_graph( 
    g::Graph, 
    graph_index::Int64,
    model::Model, 
    couplingfactor::Basic, 
    color_list::Vector{Basic}, 
    lorentz_list::Vector{Basic},
    loop_den_list::Vector{Basic}, 
    loop_den_xpt_list::Vector{Int64}, 
    ext_mom_list::Vector{Basic}, 
    scale2_list::Vector{Basic}, 
    symmetry_map::Dict{Basic,Basic}, 
    proc_str::String 
)::Nothing
#########################################################################

  graph_str = generate_visual_graph( g, model )
  graph_str = replace( graph_str, "SymEngine.Basic"=>"Basic" )

  printstyled( "\n[ Generate visual_diagram$(graph_index).tex ]\n", color=:green )
  visual_file = open( "$(proc_str)_visuals/visual_diagram$(graph_index).tex", "w" )
  write( visual_file, """
  \\documentclass{revtex4}
  \\usepackage{tikz-feynman}
  \\usepackage{rotating}
  \\usepackage{breqn}
  
  \\begin{document}
  
  $(graph_str)

  \\end{document} 
  
  """ )
  close( visual_file )


  #--------------------------------
  expression_file = open( "$(proc_str)_visuals/expression_diagram$(graph_index).out", "w" ) 
  #--------------------------------

  write( expression_file, """
  Loop Denominators: $(loop_den_list)

  Loop Denominator Exponents: $(loop_den_xpt_list) 

  """ )


  write( expression_file, """
  (* coupling factor: *) 
  $(couplingfactor)
  (* Symmetry Configuration: *) 
  $(symmetry_map)
  """ )

  n_color = length(color_list)
  for color_index âˆˆ 1:n_color
  write( expression_file, """
  (* color factor #$(color_index): *)
  $(color_list[color_index])
  
  (* color factor coefficient #$(color_index): *)
  
  $(lorentz_list[color_index])
  """ )
  end # for color_index

  close( expression_file )

  return nothing

end # function write_out_visual_graph




############################
"""
    function is_null_graph(
        one_graph::Graph
    )::Bool

Since QGRAF may keep massless tadpole in some cases, 
  we find the null graph including massless tadpole 
"""
function is_null_graph(
    one_graph::Graph
)::Bool
############################

  n_loop = one_graph.property[:n_loop]

  qi_list = [ Basic("q$(index)") for index in 1:n_loop ]
  qi_vanish_map = Dict{Basic,Basic}( qi_list .=> zero(Basic) )

  loop_mom_list = Vector{Basic}()
  loop_mass_list = Vector{Basic}()
  loop_ext_mom_list = Vector{Basic}()
  for one_edge in one_graph.edge_list
    if one_edge.property[:style] != "Loop" 
      continue
    end # if
    push!( loop_mom_list, one_edge.property[:momentum] )
    push!( loop_mass_list, one_edge.property[:particle].mass )
    push!( loop_ext_mom_list, subs( one_edge.property[:momentum], qi_vanish_map ) )
  end # for one_edge

  for n_sub in 1:n_loop
    sub_qi_list_powerset = (collectâˆ˜powerset)(qi_list,n_sub,n_sub)
    for sub_qi_list in sub_qi_list_powerset
      remnant_qi_list = setdiff( qi_list, sub_qi_list )
      # find the positions of momentums containing any qi from sub_qi_list
      sub_qi_mom_pos_list = findall( mom->has_qi(mom,sub_qi_list), loop_mom_list )
      # check if these above propagators has mass, i.e. scale
      if any( !iszero, loop_mass_list[sub_qi_mom_pos_list] )
        continue
      end # if
      if any( !iszero, loop_ext_mom_list[sub_qi_mom_pos_list] )
        continue
      end # if
      # check if these above propagators has other qi from remnant_qi_list
      if any( mom->has_qi(mom,remnant_qi_list), loop_mom_list[sub_qi_mom_pos_list] )
        continue
      end # if
      return true
    end # for sub_qi_list
  end # for n_qi

  return false

end # function is_null_graph

####################
function has_qi( 
    mom::Basic,
    qi::Basic
)::Bool
####################

  return !(iszeroâˆ˜SymEngine.coeff)(mom,qi) 

end # function has_qi


####################
function has_qi(
    mom::Basic,
    qi_list::Vector{Basic}
)::Bool
####################

  for qi in qi_list
    if has_qi(mom,qi)
      return true
    end # if
  end # for qi

  return false

end # function has_qi



##################################
# Sometimes different lorentz amplitudes have same color factor,
#   or different color factors have same lorentz amplitude.
#
function union_color_lorentz(
    lorentz_list::Vector{Basic},
    color_list::Vector{Basic} 
)::Tuple{Vector{Basic},Vector{Basic}}
##################################

  #--------------------
  union_lorentz_list = union( lorentz_list )
  union_color_list = zeros( Basic, length(union_lorentz_list) ) 
  for lorentz_index in 1:length(union_lorentz_list)
    union_lorentz = union_lorentz_list[lorentz_index]
    pos_list = findall( ==(union_lorentz), lorentz_list )
    union_color_list[lorentz_index] = (expandâˆ˜sum)( color_list[pos_list] )
  end # for lorentz_index

  #--------------------
  for lorentz_index in 1:length(union_lorentz_list)
    union_lorentz = union_lorentz_list[lorentz_index]
    coeff_list, remnant_list = (split_coeffâˆ˜get_add_vector_expand)(union_lorentz)
    
    min_str, min_pos = findmin( gen_sorted_str.(remnant_list) )
    leading_coeff = coeff_list[min_pos]

    union_lorentz_list[lorentz_index] = expand( union_lorentz//leading_coeff )
    union_color_list[lorentz_index] = expand( union_color_list[lorentz_index]*leading_coeff )
  end # for lorentz_index

  #--------------------
  union2_lorentz_list = union( union_lorentz_list )
  union2_color_list = zeros( Basic, length(union2_lorentz_list) ) 
  for lorentz_index in 1:length(union2_lorentz_list)
    union2_lorentz = union2_lorentz_list[lorentz_index]
    pos_list = findall( ==(union2_lorentz), union_lorentz_list )
    union2_color_list[lorentz_index] = (expandâˆ˜sum)( union_color_list[pos_list] )
  end # for lorentz_index

  #--------------------
  # non-zero color factors and re-alias
  nonzero_pos_list = findall( !iszero, union2_color_list )
  lorentz_list = union2_lorentz_list[nonzero_pos_list]
  color_list = union2_color_list[nonzero_pos_list]

  return lorentz_list, color_list

end # function union_color_lorentz














##########################################################################
"""
    generate_amplitude( 
        model::Model, 
        input::Dict{Any,Any} 
    )::Nothing

Generate amplitudes after `model` has been prepared.
"""
function generate_amplitude( 
    model::Model, 
    input::Dict{Any,Any} 
)::Nothing
##########################################################################

  n_inc = length(input["incoming"])
  n_loop = input["n_loop"]
  proc_str = join( [ input["incoming"]; "TO"; input["outgoing"]; "$(n_loop)Loop" ], "_" )

  couplingfactor = Basic(input["couplingfactor"]) 

  qgraf_out = YAML.load_file( "qgraf_out.dat" )
  rm( "qgraf_out.dat" )

  qgraf_list = qgraf_out["FeynmanDiagrams"]

  #------------------------------------------------  
  # Convert qgraf to Graph
  graph_list = @pipe qgraf_list |> 
               map( q -> convert_qgraf_TO_Graph( q, model ), _ ) |>
               convert( Array{Graph,1}, _ ) |>
               filter( !isnothing, _ ) |>
               sort( _, by= g->g.property[:diagram_index] )
  #------------------------------------------------  
  graph_list = filter( !is_null_graph, graph_list )
  #------------------------------------------------  


  #------------------------------------------------  
  # Generate kinematics relation
  kin_relation = generate_kin_relation( graph_list )
  file = open( "kin_relation.frm", "w" )
  write( file, (joinâˆ˜map)( x->"id $(x[1]) = $(x[2]);\n", collect(kin_relation) ) )
  close(file)

  ext_mom_list  = generate_ext_mom_list( graph_list )
  # momentum conservation
  Kn_expr = expand( 2*sum(ext_mom_list[1:n_inc])-sum(ext_mom_list)+ext_mom_list[end] )
  mom_conserv = ext_mom_list[end] => Kn_expr

  #------------------------------------------------  
  # Calculate amplitude for each graph
  cp( "$(art_dir())/scripts/contractor.frm", "contractor.frm", force=true )
  cp( "$(art_dir())/scripts/color.frm", "color.frm", force=true )

  file = open( "model_parameters.frm", "w" )
  write( file, "symbol $(join( map( string, (collectâˆ˜keys)(model.parameter_dict) ), "," ));\n" )
  close(file)

  bk_mkdir( "$(proc_str)_visuals" )
  bk_mkdir( "$(proc_str)_amplitudes" )

  # baseINC only needs information from the external fields.
  baseINC_script_str = make_baseINC_script( first(graph_list) )

  symmetry_map = to_Basic_dict( convert( Vector{Vector{String}}, input["symmetry"] ) )
  @show symmetry_map


  #-----------------------------------
  null_graph_index_list = Vector{Int64}()
  loop_den_mom_list_collect = Vector{Basic}[]
  for graph_index in 1:length(graph_list)
    g = graph_list[graph_index]
    n_inc = g.property[:n_inc]
    box_message( "Working on diagram #$(graph_index) ($(length(graph_list)))", color=:light_green )

    scale2_list = generate_scale2_list( g, kin_relation )

    color_list, lorentz_list = assemble_amplitude( g )

    color_list = simplify_color_factors( g, graph_index, color_list )

    # Sometimes evaluation to Nc can also lead to zero.
    @vars ca cf nc
    color_map = Dict([ ca=>nc, cf=>(nc^2-1)/nc ])
    nonzero_pos_list = findall( !iszero, map(x->subs(x,color_map),color_list) )
    color_list = color_list[nonzero_pos_list]

    if isempty(color_list)
      push!( null_graph_index_list, graph_index )
      continue
    end # if

    lorentz_list_pre, loop_den_list, loop_den_xpt_list = 
        factor_out_loop_den( g, lorentz_list, mom_conserv )

    lorentz_list_pre = lorentz_list_pre[nonzero_pos_list]

    if !isempty(symmetry_map) 
      lorentz_list_pre = map( x->subs(x,symmetry_map), lorentz_list_pre )
    end # if

    lorentz_list = contract_Dirac_indices_noexpand( g, graph_index, lorentz_list_pre )

    # union the same color factors or same lorentz amplitudes.
    lorentz_list, color_list = union_color_lorentz( lorentz_list, color_list )

  ###--------------------
  ##union_lorentz_list = union( lorentz_list )
  ##union_color_list = zeros( Basic, length(union_lorentz_list) ) 
  ##for lorentz_index in 1:length(union_lorentz_list)
  ##  union_lorentz = union_lorentz_list[lorentz_index]
  ##  pos_list = findall( ==(union_lorentz), lorentz_list )
  ##  union_color_list[lorentz_index] = (expandâˆ˜sum)( color_list[pos_list] )
  ##end # for lorentz_index

  ###--------------------
  ##for lorentz_index in 1:length(union_lorentz_list)
  ##  union_lorentz = union_lorentz_list[lorentz_index]
  ##  coeff_list, remnant_list = (split_coeffâˆ˜get_add_vector_expand)(union_lorentz)
  ##  
  ##  min_str, min_pos = findmin( gen_sorted_str.(remnant_list) )
  ##  leading_coeff = coeff_list[min_pos]

  ##  union_lorentz_list[lorentz_index] = expand( union_lorentz//leading_coeff )
  ##  union_color_list[lorentz_index] = expand( union_color_list[lorentz_index]*leading_coeff )
  ##end # for lorentz_index

  ###--------------------
  ##union2_lorentz_list = union( union_lorentz_list )
  ##union2_color_list = zeros( Basic, length(union2_lorentz_list) ) 
  ##for lorentz_index in 1:length(union2_lorentz_list)
  ##  union2_lorentz = union2_lorentz_list[lorentz_index]
  ##  pos_list = findall( ==(union2_lorentz), union_lorentz_list )
  ##  union2_color_list[lorentz_index] = (expandâˆ˜sum)( union_color_list[pos_list] )
  ##end # for lorentz_index

  ###--------------------
  ### non-zero color factors and re-alias
  ##nonzero_pos_list = findall( !iszero, union2_color_list )
  ##lorentz_list = union2_lorentz_list[nonzero_pos_list]
  ##color_list = union2_color_list[nonzero_pos_list]

    #-------------------------------------------
    # re-ordering
    perm = sortperm( color_list, by=gen_sorted_str )
    color_list = color_list[perm]
    lorentz_list = lorentz_list[perm]

    if isempty(lorentz_list) && isempty(color_list)
      push!( null_graph_index_list, graph_index )
      continue
    end # if

    #-----------------------------------------------------------------
    # Make sure the vacuum bubble integrals will be in standard form.
    loop_den_list, lorentz_list = canonicalize_amp( loop_den_list, lorentz_list, loop_den_mom_list_collect )
    tmp_loop_den_mom_list = map( firstâˆ˜get_args, loop_den_list )
    any( mom_list->tmp_loop_den_mom_listâŠ†mom_list||mom_listâŠ†tmp_loop_den_mom_list, 
          loop_den_mom_list_collect ) ||
      push!( loop_den_mom_list_collect, tmp_loop_den_mom_list )
    #-----------------------------------------------------------------

    min_ep_xpt = input["Amp_Min_Ep_Xpt"]
    max_ep_xpt = input["Amp_Max_Ep_Xpt"]
    write_out_amplitude( n_inc, n_loop, graph_index, couplingfactor, model.parameter_dict, 
        ext_mom_list, scale2_list, kin_relation, baseINC_script_str, 
        color_list, lorentz_list, loop_den_list, loop_den_xpt_list, 
        symmetry_map, min_ep_xpt, max_ep_xpt, proc_str )

    write_out_visual_graph( g, graph_index, model, couplingfactor, 
        color_list, lorentz_list, loop_den_list, loop_den_xpt_list, 
        ext_mom_list, scale2_list, symmetry_map, proc_str )

  end # for graph_index

  box_message( "Found number of null diagrams: $(length(null_graph_index_list))", color=:yellow )

  # remove intermediate files
  rm( "contractor.frm" )
  rm( "color.frm" )
  rm( "kin_relation.frm" )
  rm( "model_parameters.frm" )

  #---------------------
  cp( "$(art_dir())/scripts/tikz-feynman.sty", "$(proc_str)_visuals/tikz-feynman.sty" )
  cp( "$(art_dir())/scripts/generate_diagram_pdf.jl", "$(proc_str)_visuals/generate_diagram_pdf.jl" )

  @info "Users can generate PDF files for all diagrams." script="generate_diagram_pdf.jl"

  return nothing

end # function generate_amplitude

